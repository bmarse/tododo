package todo

import (
	"errors"
	"fmt"
	"os"
	"regexp"
	"strings"

	"github.com/yuin/goldmark"
	"github.com/yuin/goldmark/ast"
	"github.com/yuin/goldmark/text"
)

const indentSize = 2

func SaveTodo(todo Todo) error {
	b := []byte{}
	b = fmt.Appendf(b, "<!---\nAutomatically generated by tododo.  Only edit if you like unexpected behavior.\n-->\n")
	b = fmt.Appendf(b, "# %s\n", todo.Name)
	for _, t := range todo.Tasks {
		check := " "
		if t.Checked {
			check = "X"
		}
		padding := strings.Repeat(" ", t.Depth*indentSize)
		b = fmt.Appendf(b, "%s- [%s] %s\n", padding, check, t.Text)
	}

	if len(b) > 0 {
		err := os.WriteFile(todo.Filename, b, 0644)
		if err != nil {
			return err
		}
	}

	return nil
}

var checkRegex = regexp.MustCompile(`^\s*\[[ xX]\]\s*`)

func processListNode(node ast.Node, source []byte, depth int) []*Task {
	// We only support one level of indentation for tasks
	if depth >= 2 {
		return []*Task{}
	}
	tasks := []*Task{}

	if node.Kind() == ast.KindList {
		for listItem := node.FirstChild(); listItem != nil; listItem = listItem.NextSibling() {
			if listItem.Kind() != ast.KindListItem {
				continue
			}
			for n := listItem.FirstChild(); n != nil; n = n.NextSibling() {
				if n.Kind().String() == "TextBlock" {
					checked := false
					b := []byte{}
					for i := 0; i < n.Lines().Len(); i++ {
						line := n.Lines().At(i)
						b = append(b, line.Value(source)...)
					}
					s := string(b)
					if m := checkRegex.FindString(s); m != "" {
						checked = strings.HasPrefix(strings.ToLower(m), "[x]")
						s = strings.TrimSpace(s[len(m):])
					}

					tasks = append(tasks, &Task{
						Text:    s,
						Depth:   depth,
						Checked: checked,
					})
				}

				// Recursively process nested lists
				if n.Kind() == ast.KindList {
					tasks = append(tasks, processListNode(n, source, depth+1)...)
				}

			}
		}
	}

	return tasks
}

func LoadTodosFromMarkdown(todoFilename string) (Todo, error) {
	todolist := Todo{
		Name:     "Tododo Task List",
		Tasks:    []*Task{},
		Filename: todoFilename,
	}

	markdownContent, err := os.ReadFile(todoFilename)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			todolist.Tasks = append(todolist.Tasks, &Task{
				Text: "Add items to your todo list",
			})

			return todolist, nil
		}
		return todolist, err
	}

	md := goldmark.New()
	doc := md.Parser().Parse(text.NewReader(markdownContent))

	tasks := []*Task{}
	for node := doc.FirstChild(); node != nil; node = node.NextSibling() {
		tasks = append(tasks, processListNode(node, markdownContent, 0)...)
	}

	todolist.Tasks = tasks

	return todolist, nil
}
